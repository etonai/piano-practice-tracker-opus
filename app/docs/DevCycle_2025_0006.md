# Development Cycle 2025-0006

**Status:** In Progress  
**Start Date:** 2025-07-27  
**Focus:** Data Management and User Interface Enhancements

## Overview

This development cycle will build upon the completed user experience enhancements from DevCycle_2025_0005. The specific focus and work items are to be determined based on priorities identified from the completed phases and ongoing evaluation needs.

## Current Work Items

### Phase 1: Prune Data Interface Implementation
**Status:** Open  
**Date Added:** 2025-07-27  
**Priority:** Medium  
**Description:** Create a new "Prune Data" button in the Settings screen that navigates users to a dedicated Prune Data page. This establishes the UI foundation for future functionality that will allow deleting activities without affecting piece statistics.

**Acceptance Criteria:**
- [ ] Add "Prune Data" button to Settings screen in appropriate location
- [ ] Create new Prune Data fragment and layout
- [ ] Implement navigation from Settings to Prune Data page
- [ ] Add Prune Data destination to navigation graph
- [ ] Design initial Prune Data page layout with placeholder content
- [ ] Ensure consistent styling with existing Settings screen design
- [ ] Add proper back navigation from Prune Data page to Settings

**Technical Implementation Details:**

**Settings Button Addition:**
```xml
<!-- Add to Settings layout -->
<Button
    android:id="@+id/pruneDataButton"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Prune Data"
    android:contentDescription="Navigate to data pruning options"
    style="@style/SettingsButtonStyle" />
```

**Navigation Setup:**
```kotlin
// In Settings fragment
binding.pruneDataButton.setOnClickListener {
    findNavController().navigate(R.id.action_settings_to_prune_data)
}
```

**Files to Create:**
- `app/src/main/java/com/pseddev/playstreak/ui/prunedata/PruneDataFragment.kt`
- `app/src/main/java/com/pseddev/playstreak/ui/prunedata/PruneDataViewModel.kt`
- `app/src/main/res/layout/fragment_prune_data.xml`

**Files to Modify:**
- Settings screen layout file (add Prune Data button)
- Settings fragment (add navigation click handler)
- `app/src/main/res/navigation/nav_graph.xml` (add Prune Data destination and action)

**User Experience Features:**
- **Intuitive Access**: Prune Data button logically placed in Settings alongside other data management options
- **Clear Navigation**: Smooth transition from Settings to dedicated Prune Data interface
- **Consistent Design**: Matches existing Settings screen button styling and layout patterns
- **Future-Ready**: Establishes foundation for advanced data pruning functionality
- **Safe Exploration**: Initial page clearly indicates this is preparation for future functionality

**Implementation Sub-Phases:**
1. **Settings Integration** (0.5 days): Add Prune Data button to Settings screen and implement navigation
2. **Fragment Creation** (0.5 days): Create PruneDataFragment, ViewModel, and basic layout
3. **Navigation Setup** (0.25 days): Configure navigation graph and ensure proper back navigation
4. **Styling & Polish** (0.25 days): Ensure consistent styling and user experience flow

### Phase 2: Prune Data Access Control Toggle
**Status:** Open  
**Date Added:** 2025-07-27  
**Priority:** Medium  
**Description:** Add an "Allow Pruning of Data" toggle to the Configuration page that controls whether the Prune Data button is enabled. This provides an additional safeguard against accidental data pruning by requiring users to explicitly enable pruning access.

**Acceptance Criteria:**
- [ ] Add "Allow Pruning of Data" toggle to Configuration page
- [ ] Implement toggle state persistence using SharedPreferences
- [ ] Modify Prune Data button to check toggle state and disable/enable accordingly
- [ ] Show visual indication (grayed out) when Prune Data button is disabled
- [ ] Display helpful tooltip or text explaining why button is disabled
- [ ] Ensure toggle defaults to OFF (false) for safety
- [ ] Test toggle state changes reflect immediately in Settings screen

**Technical Implementation Details:**

**Configuration Toggle Addition:**
```xml
<!-- Add to Configuration layout -->
<androidx.appcompat.widget.SwitchCompat
    android:id="@+id/allowPruningToggle"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Allow Pruning of Data"
    android:textAppearance="?attr/textAppearanceBody1"
    android:checked="false" />

<TextView
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Enable access to data pruning features. Keep disabled for safety."
    android:textAppearance="?attr/textAppearanceCaption"
    android:layout_marginTop="4dp" />
```

**SharedPreferences Management:**
```kotlin
// In ConfigurationViewModel or utility class
companion object {
    private const val PREF_ALLOW_PRUNING = "allow_data_pruning"
}

fun setAllowPruning(allow: Boolean) {
    sharedPreferences.edit()
        .putBoolean(PREF_ALLOW_PRUNING, allow)
        .apply()
}

fun isAllowPruning(): Boolean {
    return sharedPreferences.getBoolean(PREF_ALLOW_PRUNING, false) // Default false
}
```

**Prune Data Button State Management:**
```kotlin
// In Settings fragment
private fun updatePruneDataButtonState() {
    val isPruningAllowed = configurationManager.isAllowPruning()
    binding.pruneDataButton.isEnabled = isPruningAllowed
    binding.pruneDataButton.alpha = if (isPruningAllowed) 1.0f else 0.5f
    
    if (!isPruningAllowed) {
        binding.pruneDataButton.setOnClickListener {
            // Show explanation dialog instead of navigating
            showPruningDisabledDialog()
        }
    } else {
        binding.pruneDataButton.setOnClickListener {
            findNavController().navigate(R.id.action_settings_to_prune_data)
        }
    }
}

private fun showPruningDisabledDialog() {
    AlertDialog.Builder(requireContext())
        .setTitle("Data Pruning Disabled")
        .setMessage("Enable 'Allow Pruning of Data' in Configuration to access this feature.")
        .setPositiveButton("Go to Configuration") { _, _ ->
            findNavController().navigate(R.id.action_settings_to_configuration)
        }
        .setNegativeButton("Cancel", null)
        .show()
}
```

**Files to Modify:**
- Configuration fragment layout (add toggle)
- Configuration fragment/ViewModel (toggle state management)
- Settings fragment (button state checking and updates)
- SharedPreferences or configuration utility class (persist toggle state)

**Files to Create:**
- None (using existing Configuration infrastructure)

**User Experience Features:**
- **Safety First**: Toggle defaults to OFF, preventing accidental access to pruning features
- **Clear Indication**: Disabled button is visually distinct and provides helpful feedback
- **Easy Access**: Direct navigation from disabled button dialog to Configuration page
- **Immediate Feedback**: Button state updates immediately when toggle changes
- **Persistent State**: Toggle setting remembered across app sessions
- **Guided Experience**: Clear explanation of why button is disabled and how to enable it

**Implementation Sub-Phases:**
1. **Configuration Toggle** (0.5 days): Add toggle to Configuration page with state persistence
2. **Button State Logic** (0.5 days): Implement Prune Data button enable/disable based on toggle
3. **User Feedback** (0.25 days): Add visual indicators and helpful dialogs for disabled state
4. **Integration Testing** (0.25 days): Ensure toggle changes reflect immediately across fragments

### Phase 3: Prune Oldest Activities Functionality
**Status:** Open  
**Date Added:** 2025-07-27  
**Priority:** High  
**Description:** Implement the core data pruning functionality in the Prune Data page. Add a button to delete the oldest 100 activities while preserving all piece statistics and piece records. Display the total activity count for user awareness before pruning.

**Acceptance Criteria:**
- [ ] Display total activity count at the top of Prune Data page
- [ ] Add "Prune Oldest 100 Activities" button to Prune Data page
- [ ] Implement activity deletion logic that removes oldest 100 activities by date
- [ ] Ensure piece statistics remain completely unchanged after activity deletion
- [ ] Ensure no pieces are deleted during activity pruning process
- [ ] Show confirmation dialog before executing the pruning operation
- [ ] Display progress/completion feedback to user during and after pruning
- [ ] Update activity count display after successful pruning operation
- [ ] Handle edge cases (fewer than 100 activities, empty database)

**Technical Implementation Details:**

**Activity Count Display:**
```xml
<!-- Add to top of Prune Data layout -->
<TextView
    android:id="@+id/activityCountText"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Total Activities: 0"
    android:textAppearance="?attr/textAppearanceHeadline6"
    android:gravity="center"
    android:layout_marginBottom="24dp" />
```

**Prune Button Implementation:**
```xml
<Button
    android:id="@+id/pruneOldestActivitiesButton"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Prune Oldest 100 Activities"
    android:contentDescription="Delete the oldest 100 activities without affecting piece statistics"
    style="@style/PrimaryButtonStyle"
    android:layout_marginTop="16dp" />
```

**Data Pruning Logic:**
```kotlin
// In PruneDataViewModel
suspend fun pruneOldestActivities(count: Int = 100): PruningResult {
    return withContext(Dispatchers.IO) {
        try {
            // Get oldest activities by timestamp
            val oldestActivities = repository.getOldestActivities(count)
            
            if (oldestActivities.isEmpty()) {
                return@withContext PruningResult.NoActivitiesToPrune
            }
            
            // Delete activities WITHOUT updating piece statistics
            val deletedCount = repository.deleteActivitiesWithoutStatsUpdate(oldestActivities.map { it.id })
            
            // Refresh activity count
            _activityCount.value = repository.getTotalActivityCount()
            
            PruningResult.Success(deletedCount)
        } catch (e: Exception) {
            PruningResult.Error(e.message ?: "Unknown error occurred")
        }
    }
}

// In Repository
suspend fun deleteActivitiesWithoutStatsUpdate(activityIds: List<Long>): Int {
    return database.withTransaction {
        // Delete activities directly without triggering piece statistics updates
        activityDao.deleteActivitiesByIds(activityIds)
    }
}

suspend fun getOldestActivities(count: Int): List<Activity> {
    return activityDao.getOldestActivities(count)
}
```

**Confirmation Dialog:**
```kotlin
private fun showPruningConfirmationDialog(activityCount: Int) {
    val countToPrune = minOf(100, activityCount)
    
    AlertDialog.Builder(requireContext())
        .setTitle("Confirm Activity Pruning")
        .setMessage("This will permanently delete the oldest $countToPrune activities.\n\nPiece statistics and piece records will remain unchanged.\n\nThis action cannot be undone.")
        .setPositiveButton("Prune Activities") { _, _ ->
            viewModel.pruneOldestActivities()
        }
        .setNegativeButton("Cancel", null)
        .show()
}
```

**Database DAO Updates:**
```kotlin
// In ActivityDao
@Query("SELECT * FROM activities ORDER BY date ASC LIMIT :count")
suspend fun getOldestActivities(count: Int): List<Activity>

@Query("DELETE FROM activities WHERE id IN (:activityIds)")
suspend fun deleteActivitiesByIds(activityIds: List<Long>): Int

@Query("SELECT COUNT(*) FROM activities")
suspend fun getTotalActivityCount(): Int
```

**Files to Modify:**
- `app/src/main/java/com/pseddev/playstreak/ui/prunedata/PruneDataFragment.kt` (add count display and prune button)
- `app/src/main/java/com/pseddev/playstreak/ui/prunedata/PruneDataViewModel.kt` (pruning logic and state management)
- `app/src/main/res/layout/fragment_prune_data.xml` (activity count and prune button UI)
- `app/src/main/java/com/pseddev/playstreak/data/daos/ActivityDao.kt` (pruning queries)
- `app/src/main/java/com/pseddev/playstreak/data/repository/PianoRepository.kt` (pruning methods)

**Files to Create:**
- None (using existing infrastructure)

**User Experience Features:**
- **Informed Decision**: Clear activity count helps users understand data scope before pruning
- **Safe Operation**: Confirmation dialog prevents accidental data loss
- **Preserved Statistics**: All piece statistics remain intact after pruning
- **Clear Feedback**: Progress indication and completion messages for user confidence
- **Smart Handling**: Graceful handling of edge cases (fewer than 100 activities)
- **Immediate Updates**: Activity count refreshes after successful pruning operation

**Implementation Sub-Phases:**
1. **UI Implementation** (0.5 days): Add activity count display and prune button to Prune Data page
2. **Data Layer** (1 day): Implement DAO methods and repository logic for activity pruning without stats impact
3. **ViewModel Logic** (0.5 days): Add pruning orchestration, confirmation flow, and state management
4. **Testing & Edge Cases** (0.5 days): Test with various data scenarios and edge cases

### Phase 4: Lifetime Activities Counter Implementation
**Status:** Open  
**Date Added:** 2025-07-27  
**Priority:** Low  
**Description:** Implement a dual counter system to track both current stored activities and lifetime total activities ever created. The lifetime counter increases when activities are added but never decreases when activities are pruned, providing historical usage insight.

**Acceptance Criteria:**
- [ ] Add lifetime activities counter that persists across app sessions
- [ ] Display both "Activities Stored" and "Lifetime Activities" counts on Prune Data page
- [ ] Increment lifetime counter when new activities are added to the system
- [ ] Ensure lifetime counter never decreases during pruning operations
- [ ] Initialize lifetime counter from current activity count for existing users
- [ ] Update display formatting to clearly distinguish between the two counts
- [ ] Test counter accuracy across activity creation and pruning scenarios

**Technical Implementation Details:**

**Dual Counter Display:**
```xml
<!-- Update Prune Data layout to show both counts -->
<LinearLayout
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:gravity="center"
    android:layout_marginBottom="24dp">
    
    <TextView
        android:id="@+id/activitiesStoredText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Activities Stored: 0"
        android:textAppearance="?attr/textAppearanceHeadline6" />
    
    <TextView
        android:id="@+id/lifetimeActivitiesText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Lifetime Activities: 0"
        android:textAppearance="?attr/textAppearanceSubtitle1"
        android:textColor="?attr/colorOnSurfaceVariant"
        android:layout_marginTop="4dp" />
        
</LinearLayout>
```

**Lifetime Counter Management:**
```kotlin
// In PianoRepository or utility class
class LifetimeActivityCounter(private val sharedPreferences: SharedPreferences) {
    
    companion object {
        private const val PREF_LIFETIME_ACTIVITIES = "lifetime_activities_count"
        private const val PREF_COUNTER_INITIALIZED = "lifetime_counter_initialized"
    }
    
    suspend fun initializeLifetimeCounter(currentActivityCount: Int) {
        if (!sharedPreferences.getBoolean(PREF_COUNTER_INITIALIZED, false)) {
            // For existing users, initialize with current count
            setLifetimeCount(currentActivityCount)
            sharedPreferences.edit()
                .putBoolean(PREF_COUNTER_INITIALIZED, true)
                .apply()
        }
    }
    
    fun incrementLifetimeCounter(count: Int = 1) {
        val currentLifetime = getLifetimeCount()
        setLifetimeCount(currentLifetime + count)
    }
    
    fun getLifetimeCount(): Int {
        return sharedPreferences.getInt(PREF_LIFETIME_ACTIVITIES, 0)
    }
    
    private fun setLifetimeCount(count: Int) {
        sharedPreferences.edit()
            .putInt(PREF_LIFETIME_ACTIVITIES, count)
            .apply()
    }
}
```

**Activity Creation Integration:**
```kotlin
// In Repository when adding activities
suspend fun addActivity(activity: Activity): Long {
    val activityId = activityDao.insertActivity(activity)
    
    // Increment lifetime counter
    lifetimeActivityCounter.incrementLifetimeCounter(1)
    
    // Update piece statistics as needed
    updatePieceStatisticsForActivity(activity)
    
    return activityId
}

// For bulk operations (like imports)
suspend fun addActivities(activities: List<Activity>): List<Long> {
    val activityIds = activityDao.insertActivities(activities)
    
    // Increment lifetime counter by batch size
    lifetimeActivityCounter.incrementLifetimeCounter(activities.size)
    
    return activityIds
}
```

**PruneDataViewModel Updates:**
```kotlin
// In PruneDataViewModel
data class ActivityCounts(
    val stored: Int,
    val lifetime: Int
)

private val _activityCounts = MutableLiveData<ActivityCounts>()
val activityCounts: LiveData<ActivityCounts> = _activityCounts

suspend fun loadActivityCounts() {
    val storedCount = repository.getTotalActivityCount()
    val lifetimeCount = lifetimeActivityCounter.getLifetimeCount()
    
    // Initialize lifetime counter for existing users
    lifetimeActivityCounter.initializeLifetimeCounter(storedCount)
    
    _activityCounts.value = ActivityCounts(
        stored = storedCount,
        lifetime = maxOf(lifetimeCount, storedCount) // Ensure lifetime >= stored
    )
}

// After pruning, only stored count changes
suspend fun pruneOldestActivities(count: Int = 100): PruningResult {
    // ... existing pruning logic ...
    
    // Refresh counts - only stored count will change
    loadActivityCounts()
    
    return result
}
```

**Files to Modify:**
- `app/src/main/res/layout/fragment_prune_data.xml` (dual counter display)
- `app/src/main/java/com/pseddev/playstreak/ui/prunedata/PruneDataViewModel.kt` (dual counter management)
- `app/src/main/java/com/pseddev/playstreak/data/repository/PianoRepository.kt` (activity creation hooks)
- Activity creation paths (add activity flows, import functionality)

**Files to Create:**
- `app/src/main/java/com/pseddev/playstreak/utils/LifetimeActivityCounter.kt` (counter utility class)

**User Experience Features:**
- **Historical Insight**: Users can see their total usage over time regardless of pruning
- **Current Awareness**: Clear indication of current data storage usage
- **Visual Distinction**: Different styling to distinguish current vs lifetime counts
- **Automatic Management**: Lifetime counter increments automatically with no user action required
- **Backward Compatibility**: Existing users get initialized with their current count as starting point

**Implementation Sub-Phases:**
1. **Counter Infrastructure** (0.5 days): Create LifetimeActivityCounter utility and integration points
2. **UI Updates** (0.25 days): Update Prune Data page to display both counts
3. **Activity Creation Integration** (0.5 days): Hook counter increments into all activity creation paths
4. **Testing & Validation** (0.25 days): Test counter accuracy across various scenarios

## Success Criteria

### Phase 1 Success Metrics
- [ ] Prune Data button appears correctly in Settings screen without layout issues
- [ ] Navigation from Settings to Prune Data page works smoothly
- [ ] Prune Data page displays with consistent styling and clear placeholder content
- [ ] Back navigation from Prune Data to Settings functions properly
- [ ] Button styling matches existing Settings screen design patterns
- [ ] Navigation actions are properly configured in navigation graph
- [ ] No crashes or navigation errors when accessing Prune Data functionality

### Phase 2 Success Metrics
- [ ] "Allow Pruning of Data" toggle appears correctly in Configuration page
- [ ] Toggle state persists correctly across app sessions (defaults to OFF)
- [ ] Prune Data button is disabled when toggle is OFF, enabled when toggle is ON
- [ ] Disabled button shows clear visual indication (grayed out appearance)
- [ ] Clicking disabled button shows helpful dialog with navigation to Configuration
- [ ] Toggle state changes reflect immediately in Settings screen button state
- [ ] No crashes when toggling between enabled/disabled states
- [ ] Dialog navigation to Configuration page works correctly

### Phase 3 Success Metrics
- [ ] Total activity count displays correctly at top of Prune Data page
- [ ] "Prune Oldest 100 Activities" button appears and functions properly
- [ ] Confirmation dialog appears before executing pruning operation
- [ ] Oldest 100 activities are successfully deleted when confirmed
- [ ] All piece statistics remain completely unchanged after activity deletion
- [ ] No pieces are deleted during the pruning process
- [ ] Activity count display updates immediately after successful pruning
- [ ] Edge cases handled gracefully (fewer than 100 activities, empty database)
- [ ] Progress/completion feedback provides clear user communication
- [ ] No data corruption or inconsistencies after pruning operation

### Phase 4 Success Metrics
- [ ] Both "Activities Stored" and "Lifetime Activities" counts display correctly on Prune Data page
- [ ] Lifetime counter initializes properly for existing users (using current activity count)
- [ ] Lifetime counter increments correctly when new activities are added
- [ ] Lifetime counter remains unchanged during pruning operations
- [ ] Visual distinction between stored vs lifetime counts is clear and intuitive
- [ ] Counter accuracy maintained across app sessions (persistent storage)
- [ ] All activity creation paths properly increment lifetime counter
- [ ] Counter works correctly for both individual activity creation and bulk imports
- [ ] No performance impact from counter operations
- [ ] Lifetime count is always greater than or equal to stored count

## Cycle Notes

- DevCycle_2025_0006 builds upon the completed user experience foundation from DevCycle_2025_0005
- All phases from DevCycle_2025_0005 were successfully completed on 2025-07-27
- DevCycle_2025_0005 completed: statistics display, testing button visibility, import/export text corrections, Timeline removal, and suggestions bug fixes
- Testing completed with build 1.0.8.20-beta for all DevCycle_2025_0005 features
- Timeline tab evaluation from Phase 4 may influence future development decisions
- Phase 1 established: Prune Data interface implementation for future data management capabilities
- Phase 2 established: Configuration toggle for Prune Data access control and safety
- Phase 3 established: Core data pruning functionality that preserves piece statistics while removing old activities
- Phase 4 established: Dual activity counter system for historical insight (stored vs lifetime counts)
- Phases progress from UI foundation → safety controls → data management → historical tracking

## Future Cycles

Next development cycle (2025-0007) will likely focus on:
- Production release and post-launch activities
- User feedback implementation 
- Performance monitoring and optimization
- Feature enhancements based on real usage data

## Questions

### Implementation Planning Questions

**Q1: Development Priorities**
What should be the primary focus areas for DevCycle_2025_0006?

*Considerations:*
- Timeline tab restoration decision based on user feedback
- Advanced analytics and practice insights using Phase 1 piece statistics from DevCycle_2025_0005
- Additional user experience polish and refinements
- Performance optimizations based on Timeline removal evaluation
- Preparation for production release readiness

**Q2: Timeline Tab Evaluation Results**
Based on user feedback and performance data from DevCycle_2025_0005 Phase 4, should the Timeline tab be:
- Permanently removed to maintain clean navigation and performance benefits
- Restored with improvements based on Calendar Activities Detail Mode learnings
- Kept disabled pending further evaluation

*Considerations:*
- User preference for Calendar Activities Detail Mode vs. separate Timeline
- Performance impact of Timeline data loading
- Navigation simplification benefits
- Development effort for restoration vs. alternative improvements

**Q3: Feature Enhancement Priority**
What new features or improvements should be prioritized for this cycle?

*Considerations:*
- Advanced practice analytics using piece statistics infrastructure
- Export/import enhancements beyond CSV/JSON support
- User interface polish and accessibility improvements
- Pro user feature development
- Database performance optimizations 