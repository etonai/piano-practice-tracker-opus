# Development Cycle 2025-0006

**Status:** ✅ **COMPLETED**  
**Start Date:** 2025-07-27  
**Completion Date:** 2025-07-27  
**Testing Build:** 1.0.8.21-beta  
**Focus:** Data Management and User Interface Enhancements

## Overview

This development cycle will build upon the completed user experience enhancements from DevCycle_2025_0005. The specific focus and work items are to be determined based on priorities identified from the completed phases and ongoing evaluation needs.

## Current Work Items

### Phase 1: Prune Data Interface Implementation
**Status:** ✅ **COMPLETED**  
**Date Added:** 2025-07-27  
**Date Implemented:** 2025-07-27  
**Date Completed:** 2025-07-27  
**Priority:** Medium  
**Description:** Create a new "Prune Data" button in the Settings screen that navigates users to a dedicated Prune Data page. This establishes the UI foundation for future functionality that will allow deleting activities without affecting piece statistics.

**Acceptance Criteria:**
- [x] Add "Prune Data" button to Settings screen in appropriate location
- [x] Create new Prune Data fragment and layout
- [x] Implement navigation from Settings to Prune Data page
- [x] Add Prune Data destination to navigation graph
- [x] Design initial Prune Data page layout with placeholder content
- [x] Ensure consistent styling with existing Settings screen design
- [x] Add proper back navigation from Prune Data page to Settings

**Technical Implementation Details:**

**Settings Button Addition:**
```xml
<!-- Add to Settings layout -->
<Button
    android:id="@+id/pruneDataButton"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Prune Data"
    android:contentDescription="Navigate to data pruning options"
    style="@style/SettingsButtonStyle" />
```

**Navigation Setup:**
```kotlin
// In Settings fragment
binding.pruneDataButton.setOnClickListener {
    findNavController().navigate(R.id.action_settings_to_prune_data)
}
```

**Files to Create:**
- `app/src/main/java/com/pseddev/playstreak/ui/prunedata/PruneDataFragment.kt`
- `app/src/main/java/com/pseddev/playstreak/ui/prunedata/PruneDataViewModel.kt`
- `app/src/main/res/layout/fragment_prune_data.xml`

**Files to Modify:**
- Settings screen layout file (add Prune Data button)
- Settings fragment (add navigation click handler)
- `app/src/main/res/navigation/nav_graph.xml` (add Prune Data destination and action)

**User Experience Features:**
- **Intuitive Access**: Prune Data button logically placed in Settings alongside other data management options
- **Clear Navigation**: Smooth transition from Settings to dedicated Prune Data interface
- **Consistent Design**: Matches existing Settings screen button styling and layout patterns
- **Future-Ready**: Establishes foundation for advanced data pruning functionality
- **Safe Exploration**: Initial page clearly indicates this is preparation for future functionality

**Implementation Sub-Phases:**
1. **Settings Integration** (0.5 days): Add Prune Data button to Settings screen and implement navigation
2. **Fragment Creation** (0.5 days): Create PruneDataFragment, ViewModel, and basic layout
3. **Navigation Setup** (0.25 days): Configure navigation graph and ensure proper back navigation
4. **Styling & Polish** (0.25 days): Ensure consistent styling and user experience flow

**Implementation Summary:**
- ✅ Added "Prune Data" button to MainFragment layout positioned between Import/Export and Configuration
- ✅ Created `fragment_prune_data.xml` with clear title, description, placeholder content, and safety information
- ✅ Implemented `PruneDataFragment.kt` with proper ViewModel integration and ViewBinding
- ✅ Created `PruneDataViewModel.kt` with factory pattern following existing app architecture
- ✅ Added navigation action `action_mainFragment_to_pruneDataFragment` to nav_graph.xml
- ✅ Registered PruneDataFragment as destination in navigation graph with proper label
- ✅ Added click listener in MainFragment to navigate to Prune Data page
- ✅ Used consistent styling (@style/RoundedButton, Material Design text appearances)
- ✅ Included proper accessibility support with contentDescription
- ✅ Back navigation automatically handled by Android Navigation Component

### Phase 2: Prune Data Access Control Toggle
**Status:** ✅ **COMPLETED**  
**Date Added:** 2025-07-27  
**Date Implemented:** 2025-07-27  
**Date Completed:** 2025-07-27  
**Priority:** Medium  
**Description:** Add an "Allow Pruning of Data" toggle to the Configuration page that controls whether the Prune Data button is enabled. This provides an additional safeguard against accidental data pruning by requiring users to explicitly enable pruning access.

**Acceptance Criteria:**
- [x] Add "Allow Pruning of Data" toggle to Configuration page
- [x] Implement toggle state persistence using SharedPreferences
- [x] Modify Prune Data button to check toggle state and disable/enable accordingly
- [x] Show visual indication (grayed out) when Prune Data button is disabled
- [x] Display helpful tooltip or text explaining why button is disabled
- [x] Ensure toggle defaults to OFF (false) for safety
- [x] Test toggle state changes reflect immediately in Settings screen

**Technical Implementation Details:**

**Configuration Toggle Addition:**
```xml
<!-- Add to Configuration layout -->
<androidx.appcompat.widget.SwitchCompat
    android:id="@+id/allowPruningToggle"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Allow Pruning of Data"
    android:textAppearance="?attr/textAppearanceBody1"
    android:checked="false" />

<TextView
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Enable access to data pruning features. Keep disabled for safety."
    android:textAppearance="?attr/textAppearanceCaption"
    android:layout_marginTop="4dp" />
```

**SharedPreferences Management:**
```kotlin
// In ConfigurationViewModel or utility class
companion object {
    private const val PREF_ALLOW_PRUNING = "allow_data_pruning"
}

fun setAllowPruning(allow: Boolean) {
    sharedPreferences.edit()
        .putBoolean(PREF_ALLOW_PRUNING, allow)
        .apply()
}

fun isAllowPruning(): Boolean {
    return sharedPreferences.getBoolean(PREF_ALLOW_PRUNING, false) // Default false
}
```

**Prune Data Button State Management:**
```kotlin
// In Settings fragment
private fun updatePruneDataButtonState() {
    val isPruningAllowed = configurationManager.isAllowPruning()
    binding.pruneDataButton.isEnabled = isPruningAllowed
    binding.pruneDataButton.alpha = if (isPruningAllowed) 1.0f else 0.5f
    
    if (!isPruningAllowed) {
        binding.pruneDataButton.setOnClickListener {
            // Show explanation dialog instead of navigating
            showPruningDisabledDialog()
        }
    } else {
        binding.pruneDataButton.setOnClickListener {
            findNavController().navigate(R.id.action_settings_to_prune_data)
        }
    }
}

private fun showPruningDisabledDialog() {
    AlertDialog.Builder(requireContext())
        .setTitle("Data Pruning Disabled")
        .setMessage("Enable 'Allow Pruning of Data' in Configuration to access this feature.")
        .setPositiveButton("Go to Configuration") { _, _ ->
            findNavController().navigate(R.id.action_settings_to_configuration)
        }
        .setNegativeButton("Cancel", null)
        .show()
}
```

**Files to Modify:**
- Configuration fragment layout (add toggle)
- Configuration fragment/ViewModel (toggle state management)
- Settings fragment (button state checking and updates)
- SharedPreferences or configuration utility class (persist toggle state)

**Files to Create:**
- None (using existing Configuration infrastructure)

**User Experience Features:**
- **Safety First**: Toggle defaults to OFF, preventing accidental access to pruning features
- **Clear Indication**: Disabled button is visually distinct and provides helpful feedback
- **Easy Access**: Direct navigation from disabled button dialog to Configuration page
- **Immediate Feedback**: Button state updates immediately when toggle changes
- **Persistent State**: Toggle setting remembered across app sessions
- **Guided Experience**: Clear explanation of why button is disabled and how to enable it

**Implementation Sub-Phases:**
1. **Configuration Toggle** (0.5 days): Add toggle to Configuration page with state persistence
2. **Button State Logic** (0.5 days): Implement Prune Data button enable/disable based on toggle
3. **User Feedback** (0.25 days): Add visual indicators and helpful dialogs for disabled state
4. **Integration Testing** (0.25 days): Ensure toggle changes reflect immediately across fragments

**Implementation Summary:**
- ✅ Created `ConfigurationManager` singleton utility for centralized preference management
- ✅ Added "Data Management" card to Configuration page with "Allow Pruning of Data" toggle
- ✅ Implemented toggle state persistence using SharedPreferences with safe default (false)
- ✅ Updated ConfigurationFragment to initialize and manage pruning toggle state
- ✅ Modified MainFragment to check pruning toggle state before navigation
- ✅ Added visual feedback: disabled button shows grayed out (50% alpha) when toggle is OFF
- ✅ Implemented helpful dialog when disabled button is clicked with direct navigation to Configuration
- ✅ Added onResume refresh logic to update button state when returning from Configuration
- ✅ Used Material Design SwitchMaterial component with consistent styling
- ✅ Included comprehensive explanatory text about safety and functionality
- ✅ All state changes reflect immediately without requiring app restart

### Phase 3: Prune Oldest Activities Functionality
**Status:** ✅ **COMPLETED**  
**Date Added:** 2025-07-27  
**Date Implemented:** 2025-07-27  
**Date Completed:** 2025-07-27  
**Priority:** High  
**Description:** Implement the core data pruning functionality in the Prune Data page. Add a button to delete the oldest 100 activities while preserving all piece statistics and piece records. Display the total activity count for user awareness before pruning.

**Acceptance Criteria:**
- [x] Display total activity count at the top of Prune Data page
- [x] Add "Prune Oldest 100 Activities" button to Prune Data page
- [x] Implement activity deletion logic that removes oldest 100 activities by date
- [x] Ensure piece statistics remain completely unchanged after activity deletion
- [x] Ensure no pieces are deleted during activity pruning process
- [x] Show confirmation dialog before executing the pruning operation
- [x] Display progress/completion feedback to user during and after pruning
- [x] Update activity count display after successful pruning operation
- [x] Handle edge cases (fewer than 100 activities, empty database)

**Technical Implementation Details:**

**Activity Count Display:**
```xml
<!-- Add to top of Prune Data layout -->
<TextView
    android:id="@+id/activityCountText"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Total Activities: 0"
    android:textAppearance="?attr/textAppearanceHeadline6"
    android:gravity="center"
    android:layout_marginBottom="24dp" />
```

**Prune Button Implementation:**
```xml
<Button
    android:id="@+id/pruneOldestActivitiesButton"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Prune Oldest 100 Activities"
    android:contentDescription="Delete the oldest 100 activities without affecting piece statistics"
    style="@style/PrimaryButtonStyle"
    android:layout_marginTop="16dp" />
```

**Data Pruning Logic:**
```kotlin
// In PruneDataViewModel
suspend fun pruneOldestActivities(count: Int = 100): PruningResult {
    return withContext(Dispatchers.IO) {
        try {
            // Get oldest activities by timestamp
            val oldestActivities = repository.getOldestActivities(count)
            
            if (oldestActivities.isEmpty()) {
                return@withContext PruningResult.NoActivitiesToPrune
            }
            
            // Delete activities WITHOUT updating piece statistics
            val deletedCount = repository.deleteActivitiesWithoutStatsUpdate(oldestActivities.map { it.id })
            
            // Refresh activity count
            _activityCount.value = repository.getTotalActivityCount()
            
            PruningResult.Success(deletedCount)
        } catch (e: Exception) {
            PruningResult.Error(e.message ?: "Unknown error occurred")
        }
    }
}

// In Repository
suspend fun deleteActivitiesWithoutStatsUpdate(activityIds: List<Long>): Int {
    return database.withTransaction {
        // Delete activities directly without triggering piece statistics updates
        activityDao.deleteActivitiesByIds(activityIds)
    }
}

suspend fun getOldestActivities(count: Int): List<Activity> {
    return activityDao.getOldestActivities(count)
}
```

**Confirmation Dialog:**
```kotlin
private fun showPruningConfirmationDialog(activityCount: Int) {
    val countToPrune = minOf(100, activityCount)
    
    AlertDialog.Builder(requireContext())
        .setTitle("Confirm Activity Pruning")
        .setMessage("This will permanently delete the oldest $countToPrune activities.\n\nPiece statistics and piece records will remain unchanged.\n\nThis action cannot be undone.")
        .setPositiveButton("Prune Activities") { _, _ ->
            viewModel.pruneOldestActivities()
        }
        .setNegativeButton("Cancel", null)
        .show()
}
```

**Database DAO Updates:**
```kotlin
// In ActivityDao
@Query("SELECT * FROM activities ORDER BY date ASC LIMIT :count")
suspend fun getOldestActivities(count: Int): List<Activity>

@Query("DELETE FROM activities WHERE id IN (:activityIds)")
suspend fun deleteActivitiesByIds(activityIds: List<Long>): Int

@Query("SELECT COUNT(*) FROM activities")
suspend fun getTotalActivityCount(): Int
```

**Files to Modify:**
- `app/src/main/java/com/pseddev/playstreak/ui/prunedata/PruneDataFragment.kt` (add count display and prune button)
- `app/src/main/java/com/pseddev/playstreak/ui/prunedata/PruneDataViewModel.kt` (pruning logic and state management)
- `app/src/main/res/layout/fragment_prune_data.xml` (activity count and prune button UI)
- `app/src/main/java/com/pseddev/playstreak/data/daos/ActivityDao.kt` (pruning queries)
- `app/src/main/java/com/pseddev/playstreak/data/repository/PianoRepository.kt` (pruning methods)

**Files to Create:**
- None (using existing infrastructure)

**User Experience Features:**
- **Informed Decision**: Clear activity count helps users understand data scope before pruning
- **Safe Operation**: Confirmation dialog prevents accidental data loss
- **Preserved Statistics**: All piece statistics remain intact after pruning
- **Clear Feedback**: Progress indication and completion messages for user confidence
- **Smart Handling**: Graceful handling of edge cases (fewer than 100 activities)
- **Immediate Updates**: Activity count refreshes after successful pruning operation

**Implementation Sub-Phases:**
1. **UI Implementation** (0.5 days): Add activity count display and prune button to Prune Data page
2. **Data Layer** (1 day): Implement DAO methods and repository logic for activity pruning without stats impact
3. **ViewModel Logic** (0.5 days): Add pruning orchestration, confirmation flow, and state management
4. **Testing & Edge Cases** (0.5 days): Test with various data scenarios and edge cases

**Implementation Summary:**
- ✅ Added activity count display prominently at top of Prune Data page with real-time updates
- ✅ Implemented "Prune Oldest 100 Activities" button with dynamic text showing actual count to be deleted
- ✅ Added "Export Data First" button with direct navigation to Import/Export page for safety backup
- ✅ Created ActivityDao pruning methods: `getOldestActivities()`, `deleteActivitiesByIds()`, `getTotalActivityCount()`
- ✅ Implemented PianoRepository pruning methods that bypass piece statistics updates completely
- ✅ Built comprehensive PruneDataViewModel with PruningResult sealed class for type-safe error handling
- ✅ Added confirmation dialog with detailed warning and safety information before pruning
- ✅ Implemented progress indication during pruning operation with button state management
- ✅ Created result feedback dialogs for success, no data, and error scenarios
- ✅ Added edge case handling: no activities (disables button), fewer than 100 (shows actual count)
- ✅ Integrated ConfigurationManager for lifetime activity counter initialization
- ✅ Used proper coroutines with Dispatchers.IO for background database operations
- ✅ Automatic activity count refresh after successful pruning operations

### Phase 4: Lifetime Activities Counter Implementation
**Status:** ✅ **COMPLETED**  
**Date Added:** 2025-07-27  
**Date Implemented:** 2025-07-27  
**Date Completed:** 2025-07-27  
**Priority:** Low  
**Description:** Implement a dual counter system to track both current stored activities and lifetime total activities ever created. The lifetime counter increases when activities are added but never decreases when activities are pruned, providing historical usage insight.

**Acceptance Criteria:**
- [x] Add lifetime activities counter that persists across app sessions
- [x] Display both "Activities Stored" and "Lifetime Activities" counts on Prune Data page
- [x] Increment lifetime counter when new activities are added to the system
- [x] Ensure lifetime counter never decreases during pruning operations
- [x] Initialize lifetime counter from current activity count for existing users
- [x] Update display formatting to clearly distinguish between the two counts
- [x] Test counter accuracy across activity creation and pruning scenarios
- [x] Include lifetime activity count in JSON export format
- [x] Handle lifetime activity count during JSON import (use from file if available)
- [x] Fallback to activity count if no lifetime count provided in JSON import

**Technical Implementation Details:**

**Dual Counter Display:**
```xml
<!-- Update Prune Data layout to show both counts -->
<LinearLayout
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:gravity="center"
    android:layout_marginBottom="24dp">
    
    <TextView
        android:id="@+id/activitiesStoredText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Activities Stored: 0"
        android:textAppearance="?attr/textAppearanceHeadline6" />
    
    <TextView
        android:id="@+id/lifetimeActivitiesText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Lifetime Activities: 0"
        android:textAppearance="?attr/textAppearanceSubtitle1"
        android:textColor="?attr/colorOnSurfaceVariant"
        android:layout_marginTop="4dp" />
        
</LinearLayout>
```

**Lifetime Counter Management:**
```kotlin
// In PianoRepository or utility class
class LifetimeActivityCounter(private val sharedPreferences: SharedPreferences) {
    
    companion object {
        private const val PREF_LIFETIME_ACTIVITIES = "lifetime_activities_count"
        private const val PREF_COUNTER_INITIALIZED = "lifetime_counter_initialized"
    }
    
    suspend fun initializeLifetimeCounter(currentActivityCount: Int) {
        if (!sharedPreferences.getBoolean(PREF_COUNTER_INITIALIZED, false)) {
            // For existing users, initialize with current count
            setLifetimeCount(currentActivityCount)
            sharedPreferences.edit()
                .putBoolean(PREF_COUNTER_INITIALIZED, true)
                .apply()
        }
    }
    
    fun incrementLifetimeCounter(count: Int = 1) {
        val currentLifetime = getLifetimeCount()
        setLifetimeCount(currentLifetime + count)
    }
    
    fun getLifetimeCount(): Int {
        return sharedPreferences.getInt(PREF_LIFETIME_ACTIVITIES, 0)
    }
    
    private fun setLifetimeCount(count: Int) {
        sharedPreferences.edit()
            .putInt(PREF_LIFETIME_ACTIVITIES, count)
            .apply()
    }
}
```

**Activity Creation Integration:**
```kotlin
// In Repository when adding activities
suspend fun addActivity(activity: Activity): Long {
    val activityId = activityDao.insertActivity(activity)
    
    // Increment lifetime counter
    lifetimeActivityCounter.incrementLifetimeCounter(1)
    
    // Update piece statistics as needed
    updatePieceStatisticsForActivity(activity)
    
    return activityId
}

// For bulk operations (like imports)
suspend fun addActivities(activities: List<Activity>): List<Long> {
    val activityIds = activityDao.insertActivities(activities)
    
    // Increment lifetime counter by batch size
    lifetimeActivityCounter.incrementLifetimeCounter(activities.size)
    
    return activityIds
}
```

**PruneDataViewModel Updates:**
```kotlin
// In PruneDataViewModel
data class ActivityCounts(
    val stored: Int,
    val lifetime: Int
)

private val _activityCounts = MutableLiveData<ActivityCounts>()
val activityCounts: LiveData<ActivityCounts> = _activityCounts

suspend fun loadActivityCounts() {
    val storedCount = repository.getTotalActivityCount()
    val lifetimeCount = lifetimeActivityCounter.getLifetimeCount()
    
    // Initialize lifetime counter for existing users
    lifetimeActivityCounter.initializeLifetimeCounter(storedCount)
    
    _activityCounts.value = ActivityCounts(
        stored = storedCount,
        lifetime = maxOf(lifetimeCount, storedCount) // Ensure lifetime >= stored
    )
}

// After pruning, only stored count changes
suspend fun pruneOldestActivities(count: Int = 100): PruningResult {
    // ... existing pruning logic ...
    
    // Refresh counts - only stored count will change
    loadActivityCounts()
    
    return result
}
```

**Files to Modify:**
- `app/src/main/res/layout/fragment_prune_data.xml` (dual counter display)
- `app/src/main/java/com/pseddev/playstreak/ui/prunedata/PruneDataViewModel.kt` (dual counter management)
- `app/src/main/java/com/pseddev/playstreak/data/repository/PianoRepository.kt` (activity creation hooks)
- Activity creation paths (add activity flows, import functionality)

**Files to Create:**
- `app/src/main/java/com/pseddev/playstreak/utils/LifetimeActivityCounter.kt` (counter utility class)

**User Experience Features:**
- **Historical Insight**: Users can see their total usage over time regardless of pruning
- **Current Awareness**: Clear indication of current data storage usage
- **Visual Distinction**: Different styling to distinguish current vs lifetime counts
- **Automatic Management**: Lifetime counter increments automatically with no user action required
- **Backward Compatibility**: Existing users get initialized with their current count as starting point

**Implementation Sub-Phases:**
1. **Counter Infrastructure** (0.5 days): Create LifetimeActivityCounter utility and integration points
2. **UI Updates** (0.25 days): Update Prune Data page to display both counts
3. **Activity Creation Integration** (0.5 days): Hook counter increments into all activity creation paths
4. **Testing & Validation** (0.25 days): Test counter accuracy across various scenarios

**Implementation Summary:**
- ✅ Extended ConfigurationManager with lifetime activity counter methods: `getLifetimeActivityCount()`, `setLifetimeActivityCount()`, `incrementLifetimeActivityCount()`, `initializeLifetimeCounter()`
- ✅ Updated fragment_prune_data.xml layout to display dual counters with visual hierarchy (stored count prominent, lifetime count secondary)
- ✅ Created ActivityCounts data class in PruneDataViewModel for type-safe counter management
- ✅ Updated PruneDataViewModel to use ActivityCounts instead of single activity count with backward compatibility
- ✅ Modified PruneDataFragment observers to display both stored and lifetime counts with proper formatting
- ✅ Enhanced PianoRepository constructor to accept Context parameter for ConfigurationManager access
- ✅ Updated PlayStreakApplication to pass context to repository initialization
- ✅ Modified insertActivity() method to increment lifetime counter on every activity creation
- ✅ Updated CSV and JSON import methods to increment lifetime counter in batches for performance
- ✅ Ensured pruning operations never affect lifetime counter (only stored count decreases)
- ✅ Added proper initialization logic for existing users using current activity count as baseline
- ✅ Implemented visual distinction: stored count uses primary text color, lifetime uses secondary color
- ✅ Maintained atomic counter operations with SharedPreferences for persistence
- ✅ Extended ExportInfo data class with optional lifetimeActivityCount field for JSON export compatibility
- ✅ Updated JsonExporter to include lifetime activity count in exported JSON files
- ✅ Enhanced repository exportToJson method to retrieve and pass lifetime count to exporter
- ✅ Modified JsonImporter to capture and store lifetime count from imported JSON files
- ✅ Implemented import logic to use lifetime count from JSON file when available
- ✅ Added fallback mechanism to use activity count as lifetime count when JSON lacks lifetime data
- ✅ Updated repository importFromJson to set lifetime counter based on imported data or fallback logic

### Phase 5: Navigation Button Text Clarification
**Status:** ✅ **COMPLETED**  
**Date Added:** 2025-07-27  
**Date Implemented:** 2025-07-27  
**Date Completed:** 2025-07-27  
**Priority:** Low  
**Description:** Improve button text clarity by updating navigation buttons to accurately describe their action (taking users to a screen) rather than describing the end functionality. This reduces user confusion about what the buttons actually do when clicked.

**Acceptance Criteria:**
- [x] Update "Prune Data" button text to "Data Pruning Options" in Settings screen
- [x] Update "Export Data First" button text to "Export Options" in Prune Data screen
- [x] Ensure button contentDescription attributes are updated to match new text
- [x] Verify button styling and layout remain consistent with new text lengths
- [x] Test navigation functionality remains unchanged after text updates
- [x] Update any related documentation or comments referencing old button text

**Technical Implementation Details:**

**Settings Screen Button Update:**
```xml
<!-- In MainFragment layout - Update existing button -->
<Button
    android:id="@+id/pruneDataButton"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Data Pruning Options"
    android:contentDescription="Navigate to data pruning options and settings"
    style="@style/RoundedButton" />
```

**Prune Data Screen Button Update:**
```xml
<!-- In PruneDataFragment layout - Update existing button -->
<Button
    android:id="@+id/exportDataFirstButton"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Export Options"
    android:contentDescription="Navigate to data export options"
    style="@style/RoundedButton" />
```

**Files to Modify:**
- `app/src/main/res/layout/fragment_main.xml` (update Prune Data button text)
- `app/src/main/res/layout/fragment_prune_data.xml` (update Export button text)

**Files to Create:**
- None (text-only changes to existing UI elements)

**User Experience Features:**
- **Clear Intent**: Button text accurately describes the navigation action rather than end functionality
- **Reduced Confusion**: Users understand they're navigating to options/settings rather than directly performing actions
- **Consistent Language**: Navigation buttons use "Options" terminology to indicate they lead to configuration screens
- **Maintained Functionality**: All existing navigation and functionality remains identical
- **Improved Accessibility**: Updated contentDescription provides clearer context for screen readers

**Implementation Sub-Phases:**
1. **Settings Button Update** (0.25 days): Update "Prune Data" to "Data Pruning Options" in MainFragment
2. **Export Button Update** (0.25 days): Update "Export Data First" to "Export Options" in PruneDataFragment
3. **Accessibility Review** (0.25 days): Ensure contentDescription and accessibility features are properly updated
4. **Layout Verification** (0.25 days): Test button layouts with new text lengths and verify consistent styling

**Implementation Summary:**
- ✅ Updated MainFragment button text from "Prune Data" to "Data Pruning Options" in fragment_main.xml
- ✅ Updated PruneDataFragment button text from "Export Data First" to "Export Options" in fragment_prune_data.xml
- ✅ Refreshed contentDescription attributes to match new button text and provide clearer context
- ✅ Updated navigation graph label from "Prune Data" to "Data Pruning Options" for consistency
- ✅ Updated configuration screen explanatory text to reference new "Data Pruning Options" button name
- ✅ Verified layout consistency maintained with new text lengths using existing RoundedButton style
- ✅ Confirmed navigation functionality unchanged - buttons still navigate to same destinations
- ✅ All button styling and spacing remain consistent with app design patterns

### Phase 6: Settings Page Lifetime Activity Count Display
**Status:** ✅ **COMPLETED**  
**Date Added:** 2025-07-27  
**Date Implemented:** 2025-07-27  
**Date Completed:** 2025-07-27  
**Priority:** Low  
**Description:** Add lifetime activity count to the statistics section of the Settings page (MainFragment). This extends the existing statistics display that shows Activities, Pieces, and Favorites by adding the lifetime activities count, providing users with historical usage insight directly in Settings.

**Acceptance Criteria:**
- [x] Add "Lifetime Activities" count to existing statistics section in Settings page
- [x] Position lifetime count appropriately within existing statistics layout
- [x] Ensure consistent styling with existing statistics display (Activities, Pieces, Favorites)
- [x] Retrieve lifetime count from ConfigurationManager in MainFragment
- [x] Update statistics display when returning to Settings page (onResume)
- [x] Maintain visual hierarchy with other statistics information
- [x] Test display accuracy across different lifetime count values

**Technical Implementation Details:**

**Settings Statistics Extension:**
```xml
<!-- Update existing statistics section in fragment_main.xml -->
<LinearLayout
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_marginTop="16dp"
    android:orientation="vertical">
    
    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="PlayStreak Statistics"
        android:textAppearance="?attr/textAppearanceSubtitle2"
        android:layout_marginBottom="8dp" />
        
    <TextView
        android:id="@+id/activitiesCountText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Activities: 0"
        android:textAppearance="?attr/textAppearanceBody2" />
        
    <TextView
        android:id="@+id/piecesCountText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Pieces: 0"
        android:textAppearance="?attr/textAppearanceBody2" />
        
    <TextView
        android:id="@+id/favoritesCountText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Favorites: 0"
        android:textAppearance="?attr/textAppearanceBody2" />
        
    <TextView
        android:id="@+id/lifetimeActivitiesCountText"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Lifetime Activities: 0"
        android:textAppearance="?attr/textAppearanceBody2"
        android:textColor="?attr/colorOnSurfaceVariant" />
        
</LinearLayout>
```

**MainFragment Statistics Update:**
```kotlin
// In MainFragment
private fun updateStatisticsDisplay() {
    lifecycleScope.launch {
        // Existing statistics
        val activityCount = pianoRepository.getTotalActivityCount()
        val pieceCount = pianoRepository.getTotalPieceCount()
        val favoriteCount = pianoRepository.getFavoriteCount()
        
        // New lifetime activity count
        val lifetimeCount = configurationManager.getLifetimeActivityCount()
        
        // Update UI
        binding.activitiesCountText.text = "Activities: $activityCount"
        binding.piecesCountText.text = "Pieces: $pieceCount"
        binding.favoritesCountText.text = "Favorites: $favoriteCount"
        binding.lifetimeActivitiesCountText.text = "Lifetime Activities: $lifetimeCount"
    }
}

override fun onResume() {
    super.onResume()
    updateStatisticsDisplay()
    updatePruneDataButtonState()
}
```

**Files to Modify:**
- `app/src/main/res/layout/fragment_main.xml` (add lifetime activities count TextView)
- `app/src/main/java/com/pseddev/playstreak/ui/main/MainFragment.kt` (update statistics display logic)

**Files to Create:**
- None (using existing infrastructure)

**User Experience Features:**
- **Historical Insight**: Users can see total activities ever created alongside current stored count
- **Consistent Design**: Matches existing statistics styling and layout patterns
- **Easy Access**: Lifetime count visible in primary Settings location without additional navigation
- **Visual Distinction**: Subtle color difference to distinguish lifetime from current counts
- **Real-time Updates**: Statistics refresh when returning to Settings page
- **Complete Picture**: Provides comprehensive activity usage overview in one location

**Implementation Sub-Phases:**
1. **Layout Update** (0.25 days): Add lifetime activities TextView to existing statistics section
2. **Logic Integration** (0.25 days): Update MainFragment to retrieve and display lifetime count
3. **Styling Consistency** (0.25 days): Ensure visual consistency with existing statistics
4. **Testing & Validation** (0.25 days): Test display across different data scenarios

**Implementation Summary:**
- ✅ Added `lifetimeActivitiesCountText` TextView to fragment_main.xml statistics section with proper positioning after Favorites count
- ✅ Applied consistent styling with `?attr/textAppearanceBody2` and visual distinction using `?attr/colorOnSurfaceVariant` color
- ✅ Maintained proper layout spacing with `layout_marginBottom="4dp"` for Favorites count and center horizontal alignment
- ✅ Created `updateLifetimeActivitiesDisplay()` method in MainFragment to retrieve lifetime count from ConfigurationManager
- ✅ Added appropriate imports for lifecycle management: `androidx.lifecycle.lifecycleScope` and `kotlinx.coroutines.launch`
- ✅ Integrated lifetime count updates with existing statistics system: called from `onViewCreated()`, `onResume()`, and activities count observer
- ✅ Ensured real-time updates when returning to Settings page and when activity counts change through observer pattern
- ✅ Used existing ConfigurationManager infrastructure for lifetime count retrieval without additional dependencies
- ✅ Positioned lifetime count as the last item in statistics section with subtle visual distinction from other counts

## Success Criteria

### Phase 1 Success Metrics
- [ ] Prune Data button appears correctly in Settings screen without layout issues
- [ ] Navigation from Settings to Prune Data page works smoothly
- [ ] Prune Data page displays with consistent styling and clear placeholder content
- [ ] Back navigation from Prune Data to Settings functions properly
- [ ] Button styling matches existing Settings screen design patterns
- [ ] Navigation actions are properly configured in navigation graph
- [ ] No crashes or navigation errors when accessing Prune Data functionality

### Phase 2 Success Metrics
- [ ] "Allow Pruning of Data" toggle appears correctly in Configuration page
- [ ] Toggle state persists correctly across app sessions (defaults to OFF)
- [ ] Prune Data button is disabled when toggle is OFF, enabled when toggle is ON
- [ ] Disabled button shows clear visual indication (grayed out appearance)
- [ ] Clicking disabled button shows helpful dialog with navigation to Configuration
- [ ] Toggle state changes reflect immediately in Settings screen button state
- [ ] No crashes when toggling between enabled/disabled states
- [ ] Dialog navigation to Configuration page works correctly

### Phase 3 Success Metrics
- [ ] Total activity count displays correctly at top of Prune Data page
- [ ] "Prune Oldest 100 Activities" button appears and functions properly
- [ ] Confirmation dialog appears before executing pruning operation
- [ ] Oldest 100 activities are successfully deleted when confirmed
- [ ] All piece statistics remain completely unchanged after activity deletion
- [ ] No pieces are deleted during the pruning process
- [ ] Activity count display updates immediately after successful pruning
- [ ] Edge cases handled gracefully (fewer than 100 activities, empty database)
- [ ] Progress/completion feedback provides clear user communication
- [ ] No data corruption or inconsistencies after pruning operation

### Phase 4 Success Metrics
- [ ] Both "Activities Stored" and "Lifetime Activities" counts display correctly on Prune Data page
- [ ] Lifetime counter initializes properly for existing users (using current activity count)
- [ ] Lifetime counter increments correctly when new activities are added
- [ ] Lifetime counter remains unchanged during pruning operations
- [ ] Visual distinction between stored vs lifetime counts is clear and intuitive
- [ ] Counter accuracy maintained across app sessions (persistent storage)
- [ ] All activity creation paths properly increment lifetime counter
- [ ] Counter works correctly for both individual activity creation and bulk imports
- [ ] No performance impact from counter operations
- [ ] Lifetime count is always greater than or equal to stored count

### Phase 5 Success Metrics
- [ ] "Prune Data" button text successfully updated to "Data Pruning Options" in Settings screen
- [ ] "Export Data First" button text successfully updated to "Export Options" in Prune Data screen  
- [ ] Button contentDescription attributes accurately reflect new button text
- [ ] Button layouts remain consistent and properly formatted with new text lengths
- [ ] Navigation functionality works identically before and after text changes
- [ ] No layout overflow or text truncation issues with new button text
- [ ] Accessibility testing confirms improved clarity for screen reader users
- [ ] All references to old button text are updated in code comments and documentation

### Phase 6 Success Metrics
- [ ] Lifetime Activities count displays correctly in Settings page statistics section
- [ ] Count positioning and styling matches existing statistics (Activities, Pieces, Favorites)
- [ ] Lifetime count retrieval from ConfigurationManager works properly
- [ ] Statistics display updates correctly when returning to Settings page (onResume)
- [ ] Visual hierarchy maintained with appropriate text color distinction
- [ ] Display accuracy verified across different lifetime count values (0, small numbers, large numbers)
- [ ] No layout overflow or alignment issues with new statistics entry
- [ ] Integration with existing statistics refresh logic works seamlessly

## Cycle Notes

- DevCycle_2025_0006 builds upon the completed user experience foundation from DevCycle_2025_0005
- All phases from DevCycle_2025_0005 were successfully completed on 2025-07-27
- DevCycle_2025_0005 completed: statistics display, testing button visibility, import/export text corrections, Timeline removal, and suggestions bug fixes
- Testing completed with build 1.0.8.20-beta for all DevCycle_2025_0005 features
- Timeline tab evaluation from Phase 4 may influence future development decisions
- Phase 1 established: Prune Data interface implementation for future data management capabilities
- Phase 2 established: Configuration toggle for Prune Data access control and safety
- Phase 3 established: Core data pruning functionality that preserves piece statistics while removing old activities
- Phase 4 established: Dual activity counter system for historical insight (stored vs lifetime counts)
- Phase 5 established: Navigation button text clarification for improved user experience
- Phase 6 established: Settings page lifetime activity count display for easy access to historical data
- Phases progress from UI foundation → safety controls → data management → historical tracking → UX refinement → Settings integration

## Future Cycles

Next development cycle (2025-0007) will likely focus on:
- Production release and post-launch activities
- User feedback implementation 
- Performance monitoring and optimization
- Feature enhancements based on real usage data

## Questions

### Implementation Planning Questions

**Q1: Development Priorities**
What should be the primary focus areas for DevCycle_2025_0006?

*Considerations:*
- Timeline tab restoration decision based on user feedback
- Advanced analytics and practice insights using Phase 1 piece statistics from DevCycle_2025_0005
- Additional user experience polish and refinements
- Performance optimizations based on Timeline removal evaluation
- Preparation for production release readiness

**Sonnet Recommendation:** Focus on the data management functionality outlined in Phases 1-4. This cycle establishes critical data management infrastructure that will be valuable for production users dealing with large datasets. Timeline tab evaluation can be deferred to a future cycle since the current Calendar Activities Detail Mode is providing adequate functionality. Prioritize: Phase 3 (core pruning) > Phase 1 (UI foundation) > Phase 2 (safety controls) > Phase 4 (historical tracking).

EDNOTE: The focus is on getting pruning working, but we want to establish the screens before we implement pruning. That is why the phases are in the order they are in.

**Q2: Timeline Tab Evaluation Results**
Based on user feedback and performance data from DevCycle_2025_0005 Phase 4, should the Timeline tab be:
- Permanently removed to maintain clean navigation and performance benefits
- Restored with improvements based on Calendar Activities Detail Mode learnings
- Kept disabled pending further evaluation

*Considerations:*
- User preference for Calendar Activities Detail Mode vs. separate Timeline
- Performance impact of Timeline data loading
- Navigation simplification benefits
- Development effort for restoration vs. alternative improvements

**Sonnet Recommendation:** Keep Timeline tab disabled pending further evaluation. The Timeline removal was only implemented in DC5, so there isn't sufficient user feedback yet to make a permanent decision. Monitor user behavior and feedback for 1-2 more cycles before deciding. If users aren't requesting Timeline restoration and Calendar Activities Detail Mode is meeting needs, then consider permanent removal in a future cycle.

EDNOTE: Keep the timeline disabled as it is right now. There will be time for testing after cycle 6.

**Q3: Feature Enhancement Priority**
What new features or improvements should be prioritized for this cycle?

*Considerations:*
- Advanced practice analytics using piece statistics infrastructure
- Export/import enhancements beyond CSV/JSON support
- User interface polish and accessibility improvements
- Pro user feature development
- Database performance optimizations

**Sonnet Recommendation:** Prioritize the data pruning functionality (Phases 1-4) as the primary enhancement for this cycle. This addresses a real user need for managing large datasets over time. Advanced analytics can be deferred to DC7 since the statistics infrastructure from DC5 is already in place. The pruning feature provides immediate value for data management without the complexity of analytics algorithms.

EDNOTE: Cycle 6 is about pruning.

**Q4: Settings vs Configuration Architecture**
Is the "Settings screen" mentioned in Phase 1 the same as the "Configuration page" mentioned in Phase 2, or are these separate UI components?

*Considerations:*
- Current app architecture may have MainFragment serving as settings
- Configuration might be a separate dedicated fragment
- Navigation flow between settings and configuration needs clarification
- Button placement strategy depends on which screen is which

*Cursor recommendation:* Use MainFragment as the "Settings screen" for Phase 1 (where statistics were added in DC5) and create/use a separate Configuration fragment for Phase 2 toggle. This maintains separation of concerns between user-visible settings and advanced configuration options.

**Sonnet Recommendation:** Agree with the Cursor recommendation. MainFragment should serve as the primary "Settings screen" for user-facing features like the Prune Data button. Create a separate ConfigurationFragment for advanced/technical settings like the pruning toggle. This follows good UX patterns where common actions are easily accessible while advanced configurations are separated to prevent accidental changes.

EDNOTE: Go with the Sonnet recommendation.

**Q5: Piece Statistics Preservation Mechanism**
How exactly do piece statistics get updated when activities are added/modified, and how can we ensure pruning activities doesn't trigger these updates?

*Considerations:*
- Understanding current triggers for piece statistics calculation
- Database constraints or triggers that might auto-update stats
- Whether piece statistics are calculated real-time or cached
- Impact of activity deletion on foreign key relationships

*Cursor recommendation:* Investigate the current PianoRepository methods that update piece statistics after activity operations. Implement pruning using direct DAO calls that bypass the repository's statistics update logic, ensuring piece stats remain untouched during pruning operations.

**Sonnet Recommendation:** Agree with the Cursor recommendation, but add additional safeguards. Create a dedicated `deleteActivitiesWithoutStatsUpdate()` method in the repository that explicitly bypasses all statistics calculations. Add unit tests to verify that piece statistics (total activities, last practice date, levels achieved, etc.) remain unchanged after pruning operations. Consider implementing a statistics verification method that can be run before/after pruning to confirm data integrity.

EDNOTE: Go with the Sonnet recommendation.

**Q6: Data Backup Strategy Before Pruning**
Should we implement automatic backup creation before allowing users to prune data, even with confirmations in place?

*Considerations:*
- Irreversible nature of data pruning operations
- User confidence and safety in data management
- Export functionality already exists for manual backups
- Storage and performance implications of automatic backups

*Cursor recommendation:* Do not implement automatic backup for pruning operations. Instead, prominently display information in the confirmation dialog encouraging users to export their data first, and provide a direct link to the export functionality from the Prune Data page.

**Sonnet Recommendation:** Agree with the Cursor recommendation. Automatic backups add complexity and storage overhead without guaranteeing user awareness. Instead, add a prominent "Export Data First" button on the Prune Data page that directly launches the export functionality. Include backup recommendations in the confirmation dialog with text like "Consider exporting your data first as this action cannot be undone." This educates users about backup options without forcing automatic behavior.

EDNOTE: Go with the Sonnet recommendation.

**Q7: Pruning Batch Size Configuration**
Should the "100 activities" pruning count be configurable, or should we provide multiple preset options (50, 100, 200, etc.)?

*Considerations:*
- Different users may have different storage management needs
- UI complexity vs. functionality trade-offs
- Performance implications of larger batch operations
- User education about appropriate batch sizes

*Cursor recommendation:* Keep the initial implementation with fixed 100-activity batches to maintain simplicity and ensure thorough testing. Consider adding configurability or preset options in a future development cycle based on user feedback about whether 100 is too many/few.

**Sonnet Recommendation:** Agree with the Cursor recommendation. Start with a fixed 100-activity batch size for DC6 to keep implementation simple and testable. However, display the actual number that will be deleted in the confirmation dialog (e.g., "Delete oldest 47 activities" when fewer than 100 exist). This provides transparency while maintaining simplicity. Configurability can be added in DC7 if users request different batch sizes.

EDNOTE: Go with the Sonnet recommendation.

**Q8: SharedPreferences Management Pattern**
Should pruning-related preferences be managed through a centralized configuration utility, or should each feature manage its own SharedPreferences?

*Considerations:*
- Code organization and maintainability
- Consistency with existing preference management patterns
- Future extensibility for additional configuration options
- Testing and debugging complexity

*Cursor recommendation:* Create a centralized ConfigurationManager utility class to handle all app-wide configuration preferences, including the pruning toggle and lifetime counter. This promotes consistency, makes testing easier, and provides a single source of truth for configuration state.

**Sonnet Recommendation:** Agree with the Cursor recommendation. Create a `ConfigurationManager` singleton that handles all app preferences including the pruning toggle, lifetime counter, and existing Pro user settings. This consolidates preference management, makes testing easier, and provides a clear API for all configuration needs. Include methods like `isPruningEnabled()`, `getLifetimeActivityCount()`, and `setLifetimeActivityCount()` for clean abstractions.

EDNOTE: Go with the Sonnet recommendation.

**Q9: User Onboarding for Pruning Features**
Should we include guided onboarding or help content to educate users about the pruning functionality and its safety mechanisms?

*Considerations:*
- Complexity of data management concepts for average users
- Risk of user confusion about what gets deleted vs. preserved
- Discoverability of the safety toggle in Configuration
- Support burden from user questions about pruning

*Cursor recommendation:* Add brief explanatory text on the Prune Data page itself explaining what gets deleted (activities) vs. what's preserved (pieces, statistics, favorites). Include a "Learn More" button that shows a detailed dialog explaining the safety mechanisms. This provides education without cluttering the interface.

**Sonnet Recommendation:** Agree with the Cursor recommendation. Add clear, concise explanatory text directly on the Prune Data page such as "Pruning removes old activity records while preserving all pieces, statistics, and favorites." Include an "info" icon next to key elements that shows tooltips explaining the feature. This provides just-in-time education without requiring separate onboarding flows that users might skip.

EDNOTE: Go with the Sonnet recommendation.

**Q10: Performance Testing Strategy**
What testing approach should we use to validate pruning performance with large datasets and ensure the operation completes efficiently?

*Considerations:*
- Real-world data volumes may vary significantly between users
- Database transaction performance with large DELETE operations
- UI responsiveness during pruning operations
- Memory usage during batch deletions

*Cursor recommendation:* Create automated tests with synthetic datasets of varying sizes (1K, 10K, 50K activities) to validate pruning performance. Implement progress indication during pruning operations and use background threads with proper cancellation support to maintain UI responsiveness.

**Sonnet Recommendation:** Agree with the cursor recommendation. Additionally, implement database transactions with proper error handling and rollback capabilities for pruning operations. Test with datasets up to 100K activities to ensure scalability and consider implementing chunked deletion (delete in smaller batches) if performance issues arise with large single transactions.

EDNOTE: Do not create any automated tests. 100k or 50k activities is unreasonable, as we already have limits on the number of activities, and that number is less than 10k.

### Additional Questions from Sonnet

**Q11: Database Integrity and Foreign Key Constraints**
How are activities related to pieces through foreign keys, and will deleting activities cause any cascade effects or constraint violations?

*Considerations:*
- Current database schema relationships between activities and pieces
- Whether piece statistics are stored as calculated fields or computed on-demand
- Impact of foreign key constraints on batch deletion performance
- Risk of orphaned data or referential integrity violations

**Sonnet Recommendation:** Investigate the current database schema to understand activity-piece relationships. Ensure that activity deletion doesn't trigger cascading updates to piece records. If piece statistics are stored as calculated fields that auto-update via database triggers, these triggers must be bypassed during pruning operations to preserve statistics.

EDNOTE: Go with the Sonnet recommendation.

**Q12: Pro User Feature Integration**
Should the data pruning functionality have different capabilities or limits for Pro vs Free users?

*Considerations:*
- Consistency with existing Pro/Free user feature differentiation
- Whether free users should have pruning restrictions (smaller batch sizes, frequency limits)
- Pro user enhanced features (configurable batch sizes, advanced pruning options)
- User perception of data management as a premium vs basic feature

**Sonnet Recommendation:** Keep pruning functionality identical for both Pro and Free users. Data management is a basic need, not a premium feature. This avoids creating artificial limitations that could frustrate users and maintains the principle that core app functionality should be equally accessible. Pro features should focus on enhanced analytics and usage insights rather than basic data management.

EDNOTE: Go with the Sonnet recommendation.

**Q13: Error Recovery and Data Validation**
What happens if the pruning operation fails partway through, and how do we ensure data consistency?

*Considerations:*
- Database transaction rollback capabilities
- Partial deletion scenarios and recovery procedures
- User communication about failed operations
- Data validation before and after pruning operations
- Logging and debugging for failed pruning operations

**Sonnet Recommendation:** Implement atomic transactions for all pruning operations with full rollback on any failure. Add pre-pruning validation to verify database consistency and post-pruning validation to confirm expected results. Provide clear error messages to users and log detailed error information for debugging. Consider implementing a "dry run" mode that reports what would be deleted without actually performing the operation.

EDNOTE: Go with the Sonnet recommendation.

**Q14: Configuration Migration and Versioning**
How should we handle existing users who upgrade to this version with the new configuration options?

*Considerations:*
- Default state for new configuration toggles on existing installations
- Migration strategy for SharedPreferences changes
- User awareness of new data management features
- Backward compatibility with older app versions

**Sonnet Recommendation:** Implement a configuration version system to handle migrations cleanly. New users get default settings, existing users get safe defaults (pruning disabled) with a one-time notification about the new data management features. This ensures existing users aren't surprised by new functionality while making features discoverable.

EDNOTE: There are no existing users. Do not worry about upgrade scenarios.

**Q15: Activity Selection Criteria Validation**
Should "oldest activities" be determined purely by timestamp, or should other factors be considered (activity type, piece importance, etc.)?

*Considerations:*
- Whether certain activity types are more valuable to preserve (performances vs practices)
- User-defined importance or favorite pieces that should be preserved longer
- Chronological vs strategic pruning approaches
- Complexity of selection algorithms vs user understanding

**Sonnet Recommendation:** Start with pure chronological ordering (oldest timestamp first) for simplicity and predictability. This is easiest for users to understand and verify. Advanced selection criteria (preserve performances, favorite pieces, etc.) can be added in future cycles if user feedback indicates a need for more sophisticated pruning strategies. 

EDNOTE: Go with the Sonnet recommendation.